\import Utils
\import lect10(sigmaEq)

-- Тип, являющиеся множествами, ведут себя как множества в теории множеств.
-- Это означает, что многие теоремы из нее можно доказать и в теории типов.
-- Например, мы можем доказать теорему Кантора, которая говорит, что мощность множества X строго меньше, чем мощность множества его подмножеств, то есть множества X -> \Prop.

-- Тот факт, что мощность меньше, означает, что существует инъекция из X в X -> \Prop.
-- В качестве такой инъекции мы можем просто взять предикат равенства.
-- (=) : X -> (X -> \Prop)

-- Тот факт, что мощность строго меньше, означает, что не существует сюръекции вида
-- f : X -> (X -> \Prop)
-- Это легко доказать так же как и в классическом случае.

-- Некоторые факты невозможно доказать в теории типов, так как мы не предполагаем закон исключенного третьего или аксиому выбора.
-- Например, теорема Кантора-Бернштейна, которая говорит, что если одно множество вкладывается в другое, и наоборот, то между ними есть биекция, не доказуема без исключенного третьего.
-- При необходимости мы можем добавить эти классические принципы.
-- Тогда теория станет еще больше похожа на классическую теорию множеств.

-- 1. Сюръективные функции.

\func isInj {A B : \Type} (f : A -> B) => \Pi (x y : A) -> f x = f y -> x = y

\truncated \data Trunc (A : \Type) : \Prop
  | in A

-- Сюръективные функции определяютя очевидным образом.
-- Обратите внимание, что мы используем обрезание, так как хотим, чтобы этот тип был утверждением.
\func isSur {A B : \Type} (f : A -> B) : \Prop =>
   \Pi (y : B) -> Trunc (\Sigma (x : A) (f x = y))
-- \Pi (y : B) ->        \Sigma (x : A) (f x = y)

-- 2. Лемма про факторизацию.

-- Мы докажем следующее утверждение:
-- f : A -> B => exists g : A -> C, h : C -> B, h `o` g = f, isSur g, isInj h
-- Другими словами, для любой функции f : A -> B существует ее факторизация в сюръекцию g : A -> C и инъекцию h : C -> B.
-- Факторизация означает, что композиция этих двух функций равна f.

-- Чтобы доказать, что пары, вторые компоненты которых являются утверждениями, равны, достаточно доказать, что равны их первые компоненты.
\func sigmaInc {A : \Type} (B : A -> \Prop) (t1 t2 : \Sigma (x : A) (B x)) (p : t1.1 = t2.1) : t1 = t2
  => J (\lam a' p' => \Pi (b' : B a') (q' : transport B p' t1.2 = b') -> t1 = (a',b'))
       (\lam b' q' => pmap (\lam b'' => ((t1.1,b'') : \Sigma (x : A) (B x))) q')
       p t2.2 (Path.inProp _ _)

-- Тип C -- это просто образ функции f.
-- Функции g и h определяются очевидным образом.
\func factorization {A B : \Set} (f : A -> B)
  : \Sigma (C : \Set) (g : A -> C) (h : C -> B) (\Pi (x : A) -> h (g x) = f x) (isInj h) (isSur g)
  => (\Sigma (b : B) (Trunc (\Sigma (a : A) (f a = b))),
      \lam a => (f a, in (a, idp)),
      \lam p => p.1,
      \lam a => idp,
      \lam p q (s : p.1 = q.1) => sigmaInc (\lam b => Trunc (\Sigma (a : A) (f a = b))) p q s,
      \lam p => \case p.2 \with {
        | in (a,q) => in (a, sigmaInc (\lam b => Trunc (\Sigma (a : A) (f a = b))) (f a, in (a, idp)) p q)
      })

-- 3. Определение Int.

\data Int'
  | pos' Nat
  | neg' Nat

-- Конструкторы в обычных типах данных не пересекаются.
-- Другими словами, мы всегда можем доказать, что con1 не равен con2.

-- Иногда бывает полезно определять типы данных, в которых это будет не верно.
-- Например, удобно определять целые числа как либо положительное натуральное число, либо отрицательное.
-- При этом, эти два конструктора будут пересекаться, так как положительный ноль совпадает с отрицательным.
-- Чтобы определить такой тип данных, нужно в одном или нескольких конструкторов добавить условия, которые говорят как он будет вычисляться.
-- Синтаксис такой же как и для определения функций при помощи паттерн матчинга.
-- Единственное отличие заключается в том, что не обязательно все случаи должны быть покрыты.
-- Например, мы можем определить как neg вычисляется только на zero, но не на suc.
-- Тогда neg 0 будет вычисляться в pos 0, но neg (suc n) будет уже в нормальной форме как обычный конструктор.
\data Int
  | pos Nat
  | neg (n : Nat) \elim n {
    | 0 => pos 0
  }

-- Когда мы определяем функцию над таким типом данных при помощи паттерн матчинга, система проверяет, что ее значение на эквивалентных конструкторах совпадают.
-- Например, следующее определение не пройдет, так как intEx (pos 0) равно 3, а intEx (neg 0) равно 7.
{-
\func intEx (z : Int) : Nat
  | pos n => 3
  | neg n => 7
-}

-- Паттерны, которые вычисляются, можно пропускать в паттерн матчинге.
-- Например, в следующей функции мы не определили ее значение на neg 0, но система принимает это определение.
\func intEx' (z : Int) : Nat
  | pos n => 3
  | neg (suc n) => 7

-- 4. Фактор-множества.

-- Фактор-множества -- это полезная конструкция над множествами.
-- Если A -- множество с отношением эквивалентности ~ на нем, то мы можем определить новое множество A/~ вместе с функцией in~ : A -> A/~, которая делает равными эквивалентные элементы A.
-- A : \Set
-- ~ : A -> A -> \Prop
-- A/~ : \Set
-- in~ : A -> A/~
-- (in~ a = in~ a') <-> (a ~ a')

-- Чтобы определить функцию над A/~, достаточно задать ее на произвольном элементе a : A так, чтобы эквивалентным элементам соответствовали равные результаты.
-- Мы можем использовать примерно следующий синтаксим, но в нем нет доказательства этого условия.
-- Точный синтаксис приведен ниже.
-- \func f (x : A/~) : B
--   | in~ a => b

-- Пример использвания фактор-множеств -- это рациональные числа, которые определяются как пары целых чисел с точностью до эквивалентности.
-- Rat = (\Sigma Int Int) / ~
-- Где (n,m) ~ (n',m') тогда и только тогда, когда n * m' = n' * m.

-- Фактор-множества можно определить при помощи типов данных с условиями.
-- Мы просто добавляем конструктор с параметром типа I и двумя условиями на него.
\truncated \data Quotient (A : \Type) (R : A -> A -> \Prop) : \Set
  | inR A
  | eq (a a' : A) (r : R a a') (i : I) \elim i {
    | left => inR a
    | right => inR a'
  }

-- Тогда path (eq a a' r) будет задавать равенство между двумя элементами, указанными в этих условиях.
-- В данном случае мы получаем необходимое равенство между эквивалентными элементами.
\func quotientEq {A : \Type} {R : A -> A -> \Prop} (a a' : A) (r : R a a')
  : inR a = {Quotient A R} inR a'
  => path (eq a a' r)

-- Чтобы определить функцию над Quotient A R, необходимо задать ее на элементе вида inR a и на конструкторе eq,
-- что соответствует доказательству того, что эквивалентным элементам соответствуют равные значения.
\func quotientEx {A : \Type} {R : A -> A -> \Prop} {B : \Set}
                 (f : A -> B) (p : \Pi (a a' : A) -> R a a' -> f a = f a')
                 (x : Quotient A R) : B \elim x
  | inR a => f a
  | eq a a' r i => p a a' r @ i

-- 4. \level в паттерн матчинге.

-- \sfunc -- это функции, которые не вычисляются.
\sfunc f (n : Nat) : Nat \elim n
  | 0 => 0
  | suc n => suc (f n)

-- Так как f не вычисляется, то чтобы доказать, что f n равна своей правой части, нужно использовать ключевое слово \peval, которое буквально возвращает такое доказательство.
\func lem : f 0 = 0 => \peval f 0

-- Иногда нам нужно элиминироваться из обрезанного типа в тип, который не лежит в нужном уровне, но мы можем доказать, что он удовлетворяет необходимому свойству.
-- В этом случае удобно использовать конструкцию \level.

\func isProp (A : \Type) => \Pi (x y : A) -> x = y

\func isSet (A : \Type) => \Pi (x y : A) -> isProp (x = y)

-- \level можно использовать только если функция определена как \sfunc.
-- Также его можно использовать в case, но только если он определен как \scase.
\sfunc Trunc-elim {A B : \Type} (p : isProp B) (f : A -> B) (x : Trunc A)
  : \level B p \elim x
  | in a => f a

-- 5. Лемма про эквивалентность равенств.

-- Мы докажем лемму, которая полезна когда нужно доказать, что некоторый тип является множеством.

-- Пусть у нас есть некоторый тип A, про который мы хотим доказать, что он является множеством.
-- A : \Type

-- Пусть у нас есть некоторое отношение на нем.
-- R : A -> A -> \Type

-- Допустим R x y является утверждением, R рефлексивно, и R x y влечет x = y.
-- R-isProp : \Pi (x y : A) -> isProp (R x y)
-- R-isRefl : \Pi (x : A) -> R x x
-- R-implies= : \Pi {x y : A} -> R x y -> x = y
-- Тогда A -- множество.

\func SetLemma {A : \Type}
               (R : A -> A -> \Type)
               (R-isProp : \Pi (x y : A) -> isProp (R x y))
               (R-isRefl : \Pi (x : A) -> R x x)
               (R-implies= : \Pi {x y : A} -> R x y -> x = y)
               : isSet A => {?}

-- 6. Nat -- множество.

\func \infix 4 == (n m : Nat) : Bool
  | 0, 0 => true
  | suc n, suc m => n == m
  | _, _ => false

\func T-isProp (b : Bool) : isProp (T b)
  | true => \lam _ _ => idp
  | false => \lam x _ => \case x \with {}

\func ==-refl (x : Nat) : T (x == x)
  | 0 => ()
  | suc n => ==-refl n

\func ==-= {n m : Nat} (p : T (n == m)) : n = m \elim n, m
  | 0, 0 => idp
  | suc n, 0 => absurd p
  | 0, suc n => absurd p
  | suc n, suc m => pmap suc (==-= p)

\func Nat-isSet : isSet Nat
  => SetLemma (\lam a a' => T (a == a'))
              (\lam a a' => T-isProp (a == a'))
              ==-refl
              ==-=

-- 7. Пример использования леммы.

-- Если A и B x являются множествами, то \Sigma (x : A) (B x) тоже является множеством.

\func sigma-isProp {A : \Type} (B : A -> \Type)
                   (A-isProp : isProp A)
                   (B-isProp : \Pi (x : A) -> isProp (B x))
  : isProp (\Sigma (x : A) (B x))
  => \lam p q => sigmaEq B p q (A-isProp p.1 q.1) (B-isProp q.1 (transport B (A-isProp p.1 q.1) p.2) q.2)

\func sigma-isSet {A : \Type} (B : A -> \Type)
                  (A-isSet : isSet A)
                  (B-isSet : \Pi (x : A) -> isSet (B x))
  : isSet (\Sigma (x : A) (B x))
  => SetLemma {\Sigma (x : A) (B x)}
              (\lam p q => \Sigma (s : p.1 = q.1) (transport B s p.2 = q.2))
              (\lam p q => sigma-isProp (\lam s => transport B s p.2 = q.2) (A-isSet p.1 q.1) (\lam s => B-isSet q.1 (transport B s p.2) q.2))
              (\lam p => (idp, idp))
              (\lam {p} {q} s => sigmaEq B p q s.1 s.2)